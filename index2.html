<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<title>Wat Tham Chetawan - Kruba Noi Yanwichai</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  html, body { margin:0; padding:0; height:500vh; overflow-x:hidden; background:#000; }
  video {
    position:fixed; 
    top:50%; left:50%;
    width:100vw; height:100vh;
    min-width:100vw; min-height:100vh;
    object-fit:cover; 
    transform: translate(-50%, -50%);
    z-index:1; pointer-events:none;
    opacity:0;
    transition: opacity 0.5s;
  }
  video.loaded {
    opacity:1;
  }
</style>
</head>
<body>

<img id="placeholder" src="front.jpeg" alt="Loading" 
     class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full h-full object-cover z-0" />

<video id="bg" preload="auto" muted playsinline>
  <source src="output.mp4"  type="video/mp4">
  <source src="output.webm" type="video/webm">
</video>

<img src="banner_tr.png" alt="Wat Tham Chetawan Banner"
  class="fixed top-5 left-1/2 -translate-x-1/2 z-20 opacity-90 pointer-events-none
         w-full max-w-[420px]" />

<img src="kubanoi_tr.png" alt="Kruba Noi"
  class="fixed bottom-0 left-1/2 -translate-x-1/2 z-20 pointer-events-none
         w-[60vw] max-w-[420px]  h-auto" />

<script>
  const video = document.getElementById('bg');
  let target = 0, duration = 0, docH = 0, ticking = false;

  const updateDocH = () => {
    docH = document.documentElement.scrollHeight - window.innerHeight;
  };

  const onScroll = () => {
    if (duration === 0) return; // Non fare nulla se il video non è caricato
    const frac = docH > 0 ? window.scrollY / docH : 0;
    target = duration * Math.min(Math.max(frac, 0), 1);
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(applyTime);
    }
  };

  const applyTime = () => {
    ticking = false;
    // Applica solo se differenza > 1 frame (~0.04s a 24fps) e il video è pronto
    if (video.readyState >= 2 && Math.abs(video.currentTime - target) > 0.04) {
      try {
        video.currentTime = target;
      } catch (e) {
        // Ignora errori su iOS
      }
    }
  };

  // Debug: log del formato video caricato
  video.addEventListener('loadstart', () => {
    console.log('Video loading started');
  });
  
  video.addEventListener('loadedmetadata', () => {
    duration = video.duration || 0;
    video.pause();
    console.log('Video loaded:', video.currentSrc, 'Duration:', duration);
    
    // Controlla se il video ha effettivamente contenuto
    if (duration > 0 && video.videoWidth > 0 && video.videoHeight > 0) {
      video.classList.add('loaded');
      document.getElementById('placeholder').style.opacity = '0';
      console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
    } else {
      console.log('Video loaded but invalid dimensions or duration');
    }
    
    updateDocH();
    onScroll(); // inizializza posizione
  });

  video.addEventListener('error', (e) => {
    console.log('Video error:', e);
  });

  // Fallback per iOS - mostra il video dopo 3 secondi
  setTimeout(() => {
    if (!video.classList.contains('loaded')) {
      console.log('Fallback triggered - forcing video display');
      video.classList.add('loaded');
      document.getElementById('placeholder').style.opacity = '0';
      duration = video.duration || 10;
      updateDocH();
      onScroll();
    }
  }, 3000);

  // Fix per iOS: forza il video a rimanere in pausa
  video.addEventListener('play', () => {
    video.pause();
  });

  // Listener "passive" e ricalcolo su resize
  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', () => {
    updateDocH();
    onScroll();
  }, { passive: true });
</script>

</body>
</html>
